import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { NOCODB_CONFIG } from "../_shared/nocodb-config.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
  "Access-Control-Allow-Methods": "POST, GET, OPTIONS, PUT, DELETE",
};

// Normalize URL to remove trailing slashes
const normalizeUrl = (url: string) => url?.replace(/\/+$/, '') || '';
const NOCODB_API_URL = normalizeUrl(NOCODB_CONFIG.BASE_URL);
const NOCODB_API_TOKEN = NOCODB_CONFIG.API_TOKEN;

const TABLES = {
  CAMPAIGN_LABELS: NOCODB_CONFIG.TABLES.CAMPAIGN_LABELS,
  AUTOMATED_RULES: NOCODB_CONFIG.TABLES.AUTOMATED_RULES,
  FACEBOOK_AD_ACCOUNTS: NOCODB_CONFIG.TABLES.FACEBOOK_AD_ACCOUNTS,
  FACEBOOK_INSIGHTS: NOCODB_CONFIG.TABLES.FACEBOOK_INSIGHTS_AUTO,
  CAMPAIGN_LABEL_ASSIGNMENTS: NOCODB_CONFIG.TABLES.CAMPAIGN_LABEL_ASSIGNMENTS,
  AUTOMATION_RULE_EXECUTION_LOGS: NOCODB_CONFIG.TABLES.AUTOMATION_RULE_EXECUTION_LOGS,
  SALES_REPORTS: NOCODB_CONFIG.TABLES.SALES_REPORTS,
  PENDING_REVERTS: NOCODB_CONFIG.TABLES.PENDING_REVERTS,
};

const getNocoDBHeaders = () => ({
  "xc-token": NOCODB_API_TOKEN,
  "Content-Type": "application/json",
});

interface RuleCondition {
  metric: string;
  operator: string;
  value: number;
}

interface RuleAction {
  type: string;
  value?: number | string;
  budgetMode?: "percentage" | "absolute";
  useSchedule?: boolean;
  executeAt?: string;
  autoRevert?: boolean;
  revertAtTime?: string;
  revertAction?: string;
}

// Use standard serve for compatibility
serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response(null, { headers: corsHeaders });
  }

  let pendingLogId: string | null = null;
  try {
    const { ruleId, userId, manualRun = false, dryRun = false } = await req.json();

    console.log(`\n${'='.repeat(80)}`);
    console.log(`üöÄ [AUTOMATION] Starting execution`);
    console.log(`   Rule ID: ${ruleId}`);
    console.log(`   User ID: ${userId}`);
    console.log(`   Manual Run: ${manualRun}`);
    console.log(`   Dry Run Override: ${dryRun}`);
    console.log(`   Timestamp: ${new Date().toISOString()}`);
    console.log(`${'='.repeat(80)}\n`);


    // üîí Lock the rule IMMEDIATELY to prevent race conditions
    console.log(`üîí [LOCK] Locking rule ${ruleId}...`);
    const lockResponse = await fetchWithTimeout(
      `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATED_RULES}/records`,
      {
        method: 'PATCH',
        headers: getNocoDBHeaders(),
        body: JSON.stringify({
          Id: ruleId,
          processing_status: 'processing',
          processing_started_at: new Date().toISOString(),
          last_run_at: new Date().toISOString(),
        }),
      }
    );

    if (!lockResponse.ok) {
      console.error(`‚ùå [LOCK] Failed to lock rule ${ruleId}:`, lockResponse.status);
      throw new Error(`Failed to lock rule: ${lockResponse.status}`);
    }

    console.log(`‚úÖ [LOCK] Rule ${ruleId} locked successfully`);

    // Wrap entire processing in try-finally to ensure unlock

    try {

      // Get rule details from NocoDB - Use Id (integer) not id (UUID)
      // IMPORTANT: NocoDB column is "Id" with capital I, not "id"
      const whereClause = encodeURIComponent(`(Id,eq,${ruleId})`);
      const ruleUrl = `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATED_RULES}/records?where=${whereClause}`;

      console.log(`[execute-automation-rule] Fetching rule with Id: ${ruleId} from: ${ruleUrl}`);

      const ruleResponse = await fetchWithTimeout(ruleUrl, {
        method: "GET",
        headers: getNocoDBHeaders(),
      });

      if (!ruleResponse.ok) {
        console.error("[execute-automation-rule] Failed to fetch rule:", ruleResponse.status);
        const errorText = await ruleResponse.text();
        console.error("[execute-automation-rule] Error response:", errorText);
        return new Response(JSON.stringify({ error: "Rule not found" }), {
          status: 404,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }

      const ruleData = await ruleResponse.json();
      console.log(`[execute-automation-rule] NocoDB response:`, {
        totalRules: ruleData.list?.length || 0,
        foundRule: !!ruleData.list?.[0]
      });

      const rawRule = ruleData.list?.[0];

      // ‚úÖ Debug: Log raw target_labels from NocoDB
      console.log('[execute-automation-rule] üîç Raw rule from NocoDB:', {
        Id: rawRule?.Id,
        rule_name: rawRule?.rule_name,
        target_labels_raw: rawRule?.target_labels,
        target_labels_type: typeof rawRule?.target_labels
      });

      const rule = rawRule ? parseRuleData(rawRule) : null;

      // ‚úÖ Normalize target_labels to array
      if (rule && rule.target_labels) {
        if (typeof rule.target_labels === 'string') {
          // Handle string "1" or "1,2"
          rule.target_labels = rule.target_labels.split(',').map((id: string) => id.trim());
        } else if (typeof rule.target_labels === 'number') {
          // Handle number 1
          rule.target_labels = [String(rule.target_labels)];
        } else if (Array.isArray(rule.target_labels)) {
          // Ensure all elements are strings
          rule.target_labels = rule.target_labels.map((id: any) => String(id));
        }
      }

      // ‚úÖ Apply Dry Run override
      if (rule && dryRun) {
        rule.advanced_settings = { ...rule.advanced_settings, enableDryRun: true };
        console.log('[execute-automation-rule] üß™ Dry Run mode enabled via request override');
      }

      // ‚úÖ Debug: Log parsed target_labels
      console.log('[execute-automation-rule] üîç Parsed rule:', {
        Id: rule?.Id,
        rule_name: rule?.rule_name,
        target_labels_parsed: rule?.target_labels,
        target_labels_type: typeof rule?.target_labels,
        target_labels_isArray: Array.isArray(rule?.target_labels),
        target_labels_length: rule?.target_labels?.length
      });

      if (!rule) {
        // Try to fetch all rules to see what's available
        console.log(`[execute-automation-rule] Fetching all rules to debug...`);
        const allRulesResponse = await fetchWithTimeout(
          `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATED_RULES}/records?limit=10`,
          {
            method: "GET",
            headers: getNocoDBHeaders(),
          }
        );
        if (allRulesResponse.ok) {
          const allRulesData = await allRulesResponse.json();
          console.log(`[execute-automation-rule] Available rules:`, allRulesData.list?.map((r: any) => ({ Id: r.Id, id: r.id, rule_name: r.rule_name })));
        }

        console.error("[execute-automation-rule] Rule not found with ID:", ruleId);
        return new Response(JSON.stringify({ error: "Rule not found" }), {
          status: 404,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }

      console.log(`[execute-automation-rule] Found rule: ${rule.rule_name}`);

      // Log parsed rule data for debugging
      console.log(`[execute-automation-rule] üîç Parsed rule data:`, {
        rule_name: rule.rule_name,
        conditions: rule.conditions,
        condition_logic: rule.condition_logic,
        actions: rule.actions,
        conditionsType: typeof rule.conditions,
        conditionsIsArray: Array.isArray(rule.conditions),
        conditionsLength: Array.isArray(rule.conditions) ? rule.conditions.length : 'N/A',
        actionsType: typeof rule.actions,
        actionsIsArray: Array.isArray(rule.actions),
        actionsLength: Array.isArray(rule.actions) ? rule.actions.length : 'N/A',
        actionsDetail: JSON.stringify(rule.actions)
      });

      // Validate parsed data
      if (!Array.isArray(rule.conditions) || rule.conditions.length === 0) {
        console.error('[execute-automation-rule] ‚ùå Invalid conditions:', rule.conditions);
        return new Response(
          JSON.stringify({ error: 'Invalid rule conditions - must be non-empty array' }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      if (!Array.isArray(rule.actions) || rule.actions.length === 0) {
        console.error('[execute-automation-rule] ‚ùå Invalid actions:', rule.actions);
        return new Response(
          JSON.stringify({ error: 'Invalid rule actions - must be non-empty array' }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
      }

      // Check if rule is active (skip if manual run)
      if (!rule.is_active && !manualRun) {
        console.log("[execute-automation-rule] Rule is inactive");
        return new Response(JSON.stringify({ message: "Rule is inactive", matchedCount: 0 }), {
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }

      // Get Facebook ad account token from NocoDB
      // ‚úÖ FIX: Filter by BOTH is_active=1 AND user_id to get correct user's account
      const accountWhereClause = encodeURIComponent(`(is_active,eq,1)~and(user_id,eq,${userId})`);
      const accountResponse = await fetchWithTimeout(
        `${NOCODB_API_URL}/api/v2/tables/${TABLES.FACEBOOK_AD_ACCOUNTS}/records?where=${accountWhereClause}&limit=1`,
        {
          method: "GET",
          headers: getNocoDBHeaders(),
        }
      );

      if (!accountResponse.ok) {
        console.error("[execute-automation-rule] Failed to fetch ad account");
        return new Response(JSON.stringify({ error: "No active Facebook ad account found" }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }

      const accountData = await accountResponse.json();
      const adAccount = accountData.list?.[0];

      if (!adAccount) {
        console.error("[execute-automation-rule] No active Facebook ad account found");
        return new Response(JSON.stringify({ error: "No active Facebook ad account found" }), {
          status: 400,
          headers: { ...corsHeaders, "Content-Type": "application/json" },
        });
      }

      // Get date range based on rule timeframe and ad account timezone
      const accountTimezone = adAccount.timezone_name || 'Asia/Ho_Chi_Minh';
      const { startDate, endDate } = getDateRange(rule.time_range, accountTimezone);
      const accountId = adAccount.account_id;

      console.log(`[execute-automation-rule] üìÖ Time range: ${rule.time_range} (${startDate} to ${endDate}) using timezone: ${accountTimezone}`);

      // ‚úÖ CRITICAL: Defensive check for empty target_labels
      if (!rule.target_labels || !Array.isArray(rule.target_labels) || rule.target_labels.length === 0) {
        console.error('[execute-automation-rule] ‚ùå NO TARGET LABELS SPECIFIED');
        console.error('[execute-automation-rule] ‚ùå Quy t·∫Øc ph·∫£i c√≥ √≠t nh·∫•t 1 label ƒë·ªÉ tr√°nh ·∫£nh h∆∞·ªüng t·∫•t c·∫£ campaigns');

        return new Response(
          JSON.stringify({
            error: 'Quy t·∫Øc ph·∫£i c√≥ √≠t nh·∫•t 1 label target. Vui l√≤ng ch·ªânh s·ª≠a quy t·∫Øc v√† th√™m label.',
            matchedCount: 0,
            results: []
          }),
          {
            status: 400,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      // üöÄ OPTIMIZATION: Fetch label assignments FIRST
      console.log(`[execute-automation-rule] üè∑Ô∏è Target labels: ${rule.target_labels.join(", ")}`);

      // ‚úÖ STEP 1: Create PENDING execution log IMMEDIATELY
      console.log(`[execute-automation-rule] üìù Creating PENDING execution log...`);
      const pendingLogResponse = await fetchWithTimeout(
        `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records`,
        {
          method: "POST",
          headers: getNocoDBHeaders(),
          body: JSON.stringify({
            rule_id: ruleId,
            executed_at: new Date().toISOString(),
            status: "pending",
            matched_objects_count: 0,
            executed_actions_count: 0,
            details: JSON.stringify([{ message: "B·∫Øt ƒë·∫ßu th·ª±c thi quy t·∫Øc..." }]),
          }),
        }
      );

      // let pendingLogId = null; // Moved to outer scope
      if (pendingLogResponse.ok) {
        const pendingLogData = await pendingLogResponse.json();
        pendingLogId = pendingLogData.Id;
        console.log(`[execute-automation-rule] ‚úÖ Created pending log with Id: ${pendingLogId}`);

        // üßπ CLEANUP: Keep only last 10 logs for this rule
        try {
          // Fetch IDs of logs for this rule, sorted by Id descending (newest first)
          const cleanupLimit = 10;
          const cleanupUrl = `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records?where=(rule_id,eq,${ruleId})&limit=100&sort=-Id&fields=Id`;

          const cleanupRes = await fetch(cleanupUrl, { headers: getNocoDBHeaders() });
          if (cleanupRes.ok) {
            const cleanupData = await cleanupRes.json();
            const logs = cleanupData.list || [];

            if (logs.length > cleanupLimit) {
              const logsToDelete = logs.slice(cleanupLimit); // Skip first 10, take the rest
              console.log(`[execute-automation-rule] üßπ Cleanup: Found ${logs.length} logs. Deleting ${logsToDelete.length} old logs...`);

              const deletePromises = logsToDelete.map((log: any) =>
                fetch(`${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records/${log.Id}`, {
                  method: 'DELETE',
                  headers: getNocoDBHeaders()
                })
              );

              await Promise.allSettled(deletePromises);
              console.log(`[execute-automation-rule] üßπ Cleanup: Deleted old logs.`);
            }
          }
        } catch (cleanupError) {
          console.error('[execute-automation-rule] ‚ö†Ô∏è Log cleanup failed:', cleanupError);
          // Don't fail the execution for cleanup errors
        }
      }

      // ‚úÖ FIX: Strip quotes and ensure clean numeric IDs for NocoDB query
      const cleanLabelIds = rule.target_labels.map((id: any) => String(id).replace(/"/g, '').trim());
      const labelIds = cleanLabelIds.join(",");
      const labelWhereClause = encodeURIComponent(`(label_id,in,${labelIds})`);


      console.log(`[execute-automation-rule] üîç Step 1: Fetching label assignments with where: ${labelWhereClause}`);

      const labelResponse = await fetchWithTimeout(
        `${NOCODB_API_URL}/api/v2/tables/${TABLES.CAMPAIGN_LABEL_ASSIGNMENTS}/records?where=${labelWhereClause}&limit=1000`,
        {
          method: "GET",
          headers: getNocoDBHeaders(),
        }
      );

      if (!labelResponse.ok) {
        const errorText = await labelResponse.text();
        console.error(`[execute-automation-rule] ‚ùå CRITICAL: Cannot fetch label assignments:`, {
          status: labelResponse.status,
          body: errorText,
          tableId: TABLES.CAMPAIGN_LABEL_ASSIGNMENTS
        });

        // Update log if exists
        if (pendingLogId) {
          await fetchWithTimeout(`${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records/${pendingLogId}`, {
            method: 'PATCH',
            headers: getNocoDBHeaders(),
            body: JSON.stringify({
              status: 'failed',
              details: JSON.stringify([{ message: `L·ªói fetch labels: ${errorText}` }])
            })
          });
        }

        return new Response(
          JSON.stringify({
            error: `Kh√¥ng th·ªÉ l·∫•y th√¥ng tin label assignments (${labelResponse.status}).`,
            matchedCount: 0,
            results: []
          }),
          {
            status: 500,
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      const labelData = await labelResponse.json();
      const allLabeledObjects = labelData.list || [];

      console.log(`[execute-automation-rule] üìã Fetched ${allLabeledObjects.length} total label assignments from NocoDB`);

      // Filter by user_id
      const labeledObjects = allLabeledObjects.filter((obj: any) => obj.user_id === userId);
      console.log(`[execute-automation-rule] üìã Filtered to ${labeledObjects.length} assignments for user ${userId}`);

      // Extract IDs based on scope
      const labeledCampaignIds = labeledObjects
        .map((obj: any) => obj.campaign_id)
        .filter((id: any) => id);

      const labeledAdSetIds = labeledObjects
        .map((obj: any) => obj.adset_id)
        .filter((id: any) => id);

      const labeledAdIds = labeledObjects
        .map((obj: any) => obj.ad_id)
        .filter((id: any) => id);

      console.log(`[execute-automation-rule] üè∑Ô∏è Found labeled objects:`, {
        campaigns: labeledCampaignIds.length,
        adsets: labeledAdSetIds.length,
        ads: labeledAdIds.length
      });

      if (labeledCampaignIds.length === 0 && labeledAdSetIds.length === 0 && labeledAdIds.length === 0) {
        console.log('[execute-automation-rule] ‚ö†Ô∏è No labeled objects found for this rule');

        // Update log
        if (pendingLogId) {
          await fetchWithTimeout(`${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records/${pendingLogId}`, {
            method: 'PATCH',
            headers: getNocoDBHeaders(),
            body: JSON.stringify({
              status: 'success', // Technically success, just 0 matches
              matched_objects_count: 0,
              details: JSON.stringify([{ message: "Kh√¥ng t√¨m th·∫•y ƒë·ªëi t∆∞·ª£ng n√†o c√≥ nh√£n ph√π h·ª£p." }])
            })
          });
        }

        return new Response(
          JSON.stringify({
            message: 'No labeled objects found',
            matchedCount: 0,
            results: [],
            debug: {
              totalAssignments: allLabeledObjects.length,
              filteredAssignments: labeledObjects.length,
              userIdPassed: userId,
              labelIds: labelIds,
              firstAssignmentUserId: allLabeledObjects[0]?.user_id,
              labelWhereClause: labelWhereClause
            }
          }),
          {
            headers: { ...corsHeaders, "Content-Type": "application/json" }
          }
        );
      }

      // 0. üîÑ FORCE SYNC DATA BEFORE FETCHING
      // Call sync-ads-cron for this specific account to ensure fresh data
      // Only do this if we have a valid accountId
      if (accountId) {
        console.log(`[execute-automation-rule] üîÑ Triggering force sync for account ${accountId}...`);
        try {
          // Construct sync URL - assume sibling function
          // In Supabase functions, we can call other functions via URL
          const syncUrl = `${req.url.replace('execute-automation-rule', 'sync-ads-cron')}`;

          const syncResponse = await fetch(syncUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': req.headers.get('Authorization') || ''
            },
            body: JSON.stringify({
              target_account_id: accountId,
              date_preset: 'today', // Sync today's data for rules
              limit: 500 // Limit to avoid timeout
            })
          });

          if (syncResponse.ok) {
            console.log(`[execute-automation-rule] ‚úÖ Force sync completed successfully.`);
          } else {
            console.warn(`[execute-automation-rule] ‚ö†Ô∏è Force sync failed status: ${syncResponse.status}`);
          }
        } catch (syncError) {
          console.error(`[execute-automation-rule] ‚ö†Ô∏è Force sync error:`, syncError);
          // Continue anyway, don't block rule execution
        }
      }

      // ‚ö†Ô∏è Logic:
      // 1. Filter by user_id and account_id
      // 2. Filter by level matches rule scope (crucial!)
      // 3. Filter by IDs (Campaign OR AdSet OR Ad)

      let idFilter = '';
      const conditions = [];

      // Add ID filters based on what we found
      if (labeledCampaignIds.length > 0) {
        conditions.push(`(campaign_id,in,${labeledCampaignIds.join(',')})`);
      }
      if (labeledAdSetIds.length > 0) {
        conditions.push(`(adset_id,in,${labeledAdSetIds.join(',')})`);
      }
      if (labeledAdIds.length > 0) {
        conditions.push(`(ad_id,in,${labeledAdIds.join(',')})`);
      }

      // Combine ID filters with OR logic if multiple types exist
      if (conditions.length > 1) {
        idFilter = `(${conditions.join('~or')})`;
      } else if (conditions.length === 1) {
        idFilter = conditions[0];
      }

      // Determine level filter based on rule scope
      // If scope is 'campaign', we want campaign level insights
      // If scope is 'adset', we want adset level insights
      const levelFilter = `(level,eq,${rule.scope})`;

      const insightsWhereClause = encodeURIComponent(
        `(user_id,eq,${userId})~and(account_id,eq,${accountId})~and${levelFilter}~and${idFilter}`
      );

      const insightsUrl = `${NOCODB_API_URL}/api/v2/tables/${TABLES.FACEBOOK_INSIGHTS}/records?where=${insightsWhereClause}&limit=1000&sort=-date_start`;

      console.log(`[execute-automation-rule] üîç Step 2: Fetching insights for scope ${rule.scope}`);
      console.log(`[execute-automation-rule]   URL: ${insightsUrl.substring(0, 150)}...`);

      const insightsResponse = await fetchWithTimeout(insightsUrl, {
        method: "GET",
        headers: getNocoDBHeaders(),
      });

      console.log(`[execute-automation-rule] üìä NocoDB insights response status: ${insightsResponse.status}`);

      if (!insightsResponse.ok) {
        const errorText = await insightsResponse.text();
        console.error(`[execute-automation-rule] ‚ùå Error fetching insights from NocoDB:`);
        console.error(`[execute-automation-rule]   Status: ${insightsResponse.status}`);
        console.error(`[execute-automation-rule]   Response: ${errorText}`);
        throw new Error(`Failed to fetch insights from NocoDB: ${insightsResponse.status} - ${errorText}`);
      }

      const insightsData = await insightsResponse.json();
      let allInsights = insightsData.list || [];

      console.log(`[execute-automation-rule] üìà Fetched ${allInsights.length} insights for scope ${rule.scope}`);

      // Filter by date range on client side (NocoDB doesn't support date comparison in WHERE)
      const insights = allInsights.filter((insight: any) => {
        if (!insight.date_start) return false;
        const insightDate = insight.date_start.split('T')[0]; // Normalize to YYYY-MM-DD
        return insightDate >= startDate && insightDate <= endDate;
      });

      console.log(`[execute-automation-rule] ‚úÖ Filtered to ${insights.length} insights within date range ${startDate} to ${endDate}`);

      if (insights.length > 0) {
        const sample = insights[0];
        console.log(`[execute-automation-rule] üìä Sample insight:`, {
          id: rule.scope === 'campaign' ? sample.campaign_id : rule.scope === 'adset' ? sample.adset_id : sample.ad_id,
          name: sample.name || sample.campaign_name || sample.adset_name || sample.ad_name,
          date_start: sample.date_start,
          spend: sample.spend,
          results: sample.results,
          level: sample.level
        });
      } else {
        console.log(`[execute-automation-rule] ‚ö†Ô∏è No insights found for labeled objects in date range: ${startDate} to ${endDate}`);
      }

      // ‚ú® NEW: Fetch sales reports from NocoDB
      console.log(`[execute-automation-rule] üìû Fetching sales reports...`);
      const salesWhereClause = encodeURIComponent(`(user_id,eq,${userId})`);
      const salesUrl = `${NOCODB_API_URL}/api/v2/tables/${TABLES.SALES_REPORTS}/records?where=${salesWhereClause}&limit=10000`;

      const salesResponse = await fetchWithTimeout(salesUrl, {
        method: "GET",
        headers: getNocoDBHeaders(),
      });

      let salesData: any[] = [];
      if (salesResponse.ok) {
        const salesResult = await salesResponse.json();
        salesData = salesResult.list || [];
        console.log(`[execute-automation-rule] üìä Fetched ${salesData.length} sales reports`);
      } else {
        console.log(`[execute-automation-rule] ‚ö†Ô∏è Could not fetch sales reports: ${salesResponse.status}`);
      }

      // Group sales by campaign_id OR adset_id based on rule scope
      const salesByObject: Record<string, {
        appointments: number;
        phones: number;
        service_revenue: number;
        total_revenue: number;
      }> = {};

      salesData.forEach((sale) => {
        // Determine the grouping key based on rule scope
        let objectId: string | null = null;

        if (rule.scope === 'adset' && sale.adset_id) {
          objectId = sale.adset_id;
        } else if (sale.campaign_id) {
          objectId = sale.campaign_id;
        }

        if (!objectId || !sale.report_date) return;

        const key = `${objectId}_${sale.report_date.split('T')[0]}`;

        if (!salesByObject[key]) {
          salesByObject[key] = {
            appointments: 0,
            phones: 0,
            service_revenue: 0,
            total_revenue: 0
          };
        }

        // Count appointments (scheduled or completed)
        if (sale.appointment_status === 'scheduled' || sale.appointment_status === 'completed') {
          salesByObject[key].appointments++;
        }

        // Count phones collected
        if (sale.phone_number && sale.phone_number.trim().length > 0) {
          salesByObject[key].phones++;
        }

        // Sum revenues
        salesByObject[key].service_revenue += parseFloat(sale.service_revenue || 0);
        salesByObject[key].total_revenue += parseFloat(sale.total_revenue || 0);
      });

      console.log(`[execute-automation-rule] üìà Grouped sales into ${Object.keys(salesByObject).length} ${rule.scope}-date combinations`);

      // ‚ÑπÔ∏è Insights already filtered by labeled campaigns at fetch time - no need to filter again
      console.log('[execute-automation-rule] ‚ÑπÔ∏è Insights already filtered by labeled campaigns at fetch time');

      // Aggregate data by scope
      const aggregatedData = aggregateByScope(insights, rule.scope);

      console.log(`[execute-automation-rule] Aggregated into ${aggregatedData.length} groups`);

      // ‚ú® NEW: Enrich aggregated data with sales metrics
      const enrichedData = aggregatedData.map((obj: any) => {
        // Aggregate sales data across all dates for this object (campaign or adset)
        const objectSales = Object.entries(salesByObject)
          .filter(([key]) => key.startsWith(`${obj.id}_`))
          .reduce((acc, [, sales]) => ({
            appointments: acc.appointments + sales.appointments,
            phones: acc.phones + sales.phones,
            service_revenue: acc.service_revenue + sales.service_revenue,
            total_revenue: acc.total_revenue + sales.total_revenue
          }), { appointments: 0, phones: 0, service_revenue: 0, total_revenue: 0 });

        // Calculate Manager metrics
        const booking_rate = obj.results > 0 ? (objectSales.appointments / obj.results) * 100 : 0;
        const phone_collection_rate = obj.results > 0 ? (objectSales.phones / obj.results) * 100 : 0;
        const cost_per_appointment = objectSales.appointments > 0 ? obj.spend / objectSales.appointments : 0;
        const cost_per_service_revenue = objectSales.service_revenue > 0 ? obj.spend / objectSales.service_revenue : 0;

        // Calculate Director metrics
        const marketing_revenue_ratio = objectSales.total_revenue > 0 ? (obj.spend / objectSales.total_revenue) * 100 : 0;
        const marketing_service_ratio = objectSales.service_revenue > 0 ? (obj.spend / objectSales.service_revenue) * 100 : 0;
        const marketing_daily_ratio = objectSales.total_revenue > 0 ? obj.spend / objectSales.total_revenue : 0;
        const roi = objectSales.total_revenue > 0 ? ((objectSales.total_revenue - obj.spend) / obj.spend) * 100 : 0;
        const roas = obj.spend > 0 ? objectSales.total_revenue / obj.spend : 0;

        return {
          ...obj,
          // Sales data
          appointments: objectSales.appointments,
          phones: objectSales.phones,
          service_revenue: objectSales.service_revenue,
          total_revenue: objectSales.total_revenue,
          // Manager metrics
          booking_rate,
          phone_collection_rate,
          cost_per_appointment,
          cost_per_service_revenue,
          // Director metrics
          marketing_revenue_ratio,
          marketing_service_ratio,
          marketing_daily_ratio,
          roi,
          roas
        };
      });

      if (enrichedData.length > 0) {
        console.log(`[execute-automation-rule] üìä Sample enriched data:`, {
          id: enrichedData[0].id,
          name: enrichedData[0].name,
          spend: enrichedData[0].spend,
          results: enrichedData[0].results,
          appointments: enrichedData[0].appointments,
          booking_rate: enrichedData[0].booking_rate?.toFixed(2) + '%',
          roi: enrichedData[0].roi?.toFixed(2) + '%',
          roas: enrichedData[0].roas?.toFixed(2)
        });
      }

      // ‚úÖ STEP 2: Update PENDING execution log (instead of creating new one)
      console.log(`[execute-automation-rule] üìù Updating PENDING execution log...`);
      if (pendingLogId) {
        await fetchWithTimeout(
          `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records/${pendingLogId}`,
          {
            method: "PATCH",
            headers: getNocoDBHeaders(),
            body: JSON.stringify({
              details: JSON.stringify([{ message: "ƒêang ki·ªÉm tra ƒëi·ªÅu ki·ªán..." }]),
            }),
          }
        );
      }

      // Update rule status to pending
      await fetchWithTimeout(
        `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATED_RULES}/records/${rule.Id}`,
        {
          method: "PATCH",
          headers: getNocoDBHeaders(),
          body: JSON.stringify({
            last_execution_status: "pending",
          }),
        }
      );

      // Define executionResults array BEFORE loops
      const executionResults = [];

      // ‚úÖ STEP 2: Evaluate conditions with detailed logging (now using enrichedData)
      console.log(`[execute-automation-rule] üìã Evaluating conditions:`, JSON.stringify(rule.conditions));
      console.log(`[execute-automation-rule] üîÄ Condition logic: ${rule.condition_logic}`);
      console.log(`[execute-automation-rule] üîç Conditions validation:`, {
        isArray: Array.isArray(rule.conditions),
        length: rule.conditions?.length,
        firstCondition: rule.conditions?.[0]
      });

      const matchedObjects = [];

      // We will iterate through ALL objects to evaluate conditions and log everything
      for (const obj of enrichedData) {
        const matched = evaluateConditions(obj, rule.conditions, rule.condition_logic);

        // ‚úÖ Collect matched conditions details
        const conditionsDetail = rule.conditions.map((condition: RuleCondition) => {
          const value = obj[condition.metric];
          const conditionMet = evaluateSingleCondition(value, condition.operator, condition.value);
          return {
            metric: condition.metric,
            operator: condition.operator,
            threshold: condition.value,
            actualValue: value,
            met: conditionMet
          };
        });

        // ‚úÖ ENABLED: Log each object evaluation for debugging
        console.log(`[execute-automation-rule] üîç Object "${obj.name}" (${obj.id}):`, {
          spend: obj.spend,
          results: obj.results,
          cost_per_result: obj.results > 0 ? (obj.spend / obj.results).toFixed(2) : 'N/A',
          conditionsDetail,
          matched: matched ? '‚úÖ MATCHED' : '‚ùå NOT MATCHED'
        });

        if (matched) {
          matchedObjects.push({
            ...obj,
            _matched: true,
            _matchedConditions: conditionsDetail
          });
        } else {
          // ‚ö†Ô∏è NEW: Log "Condition not met" events
          // Only log if we have results/spend to show (optional, but keeps logs cleaner)
          // For now, log everything as requested by user
          executionResults.push({
            objectId: obj.id,
            objectName: obj.name,
            campaignId: obj.campaign_id || obj.id,
            campaignName: obj.campaign_name || obj.name,
            level: obj.level || rule.scope,
            action: rule.actions.map((a: any) => a.type).join(', '), // Show intended actions
            result: "condition_failed",
            status: "skipped", // Keep status as skipped/success/failed for Badge color
            reason: "Kh√¥ng ƒë·∫°t ƒëi·ªÅu ki·ªán",
            matchedConditions: conditionsDetail,
            metrics: {
              spend: obj.spend,
              results: obj.results,
              roi: obj.roi,
              roas: obj.roas
            },
            timestamp: new Date().toISOString()
          });
        }
      }

      console.log(`[execute-automation-rule] ${matchedObjects.length} objects matched conditions`);

      // Execute actions for MATCHED objects only
      for (const obj of matchedObjects) {
        console.log(`[execute-automation-rule] üéØ Processing matched object: ${obj.name} (${obj.id})`);
        console.log(`[execute-automation-rule] üìã Actions to execute (${rule.actions.length}):`,
          rule.actions.map((a: RuleAction) => ({
            type: a.type,
            value: a.value,
            budgetMode: a.budgetMode,
            autoRevert: a.autoRevert,
            revertAtTime: a.revertAtTime,
            revertAfterHours: a.revertAfterHours,
            revertAction: a.revertAction
          }))
        );

        for (const action of rule.actions) {
          try {
            // ‚úÖ NEW: Check execution history before executing
            // ‚úÖ FIX: Check execution history for ALL actions (turn_off, turn_on, budget, etc.)
            // Previously this was restricted to budget changes only, causing turn_off to loop.
            const historyCheck = await checkExecutionHistory(
              rule.Id,
              obj.id,
              rule.scope,
              userId,
              action.type,
              { ...rule.advanced_settings, manualRun } // ‚úÖ Pass manualRun
            );

            if (!historyCheck.canExecute) {
              console.log(`[execute-automation-rule] ‚è∏Ô∏è Skipping ${action.type} on ${obj.id}:`, historyCheck.reason);
              executionResults.push({
                objectId: obj.id,
                objectName: obj.name,
                campaignId: obj.campaign_id || obj.id,
                campaignName: obj.campaign_name || obj.name,
                level: obj.level || rule.scope,
                action: action.type,
                result: "skipped",
                status: "skipped",
                reason: historyCheck.reason,
                // executionCount: historyCheck.executionCount, // REMOVED: Not returned by checkExecutionHistory
                timestamp: new Date().toISOString()
              });
              continue;
            }

            // Check if action should be executed at specific time
            if (action.executeAt && !shouldExecuteNow(action.executeAt)) {
              console.log(`[execute-automation-rule] Skipping action ${action.type} - scheduled for ${action.executeAt}`);
              continue;
            }

            console.log(`[execute-automation-rule] ‚ñ∂Ô∏è Executing ${action.type} on ${obj.id}`, {
              actionType: action.type,
              actionValue: action.value,
              budgetMode: action.budgetMode
            });

            // ‚úÖ NEW: Check minRoasThreshold for increase_budget action
            const advSettings = rule.advanced_settings || {};
            if (action.type === 'increase_budget' && advSettings.enableSafeGuards && advSettings.minRoasThreshold) {
              const objectRoas = obj.roas || 0;
              const minRoas = advSettings.minRoasThreshold;

              if (objectRoas < minRoas) {
                console.log(`[execute-automation-rule] ‚ö†Ô∏è ROAS check failed: ${objectRoas} < ${minRoas} (threshold)`);
                executionResults.push({
                  objectId: obj.id,
                  objectName: obj.name,
                  campaignId: obj.campaign_id || obj.id,
                  campaignName: obj.campaign_name || obj.name,
                  level: obj.level || rule.scope,
                  action: action.type,
                  result: "skipped",
                  status: "skipped",
                  reason: `ROAS (${objectRoas.toFixed(2)}) th·∫•p h∆°n ng∆∞·ª°ng t·ªëi thi·ªÉu (${minRoas})`,
                  timestamp: new Date().toISOString()
                });
                continue;
              }
              console.log(`[execute-automation-rule] ‚úÖ ROAS check passed: ${objectRoas} >= ${minRoas}`);
            }

            // üî¥üî¥üî¥ CRITICAL DEBUG LOG üî¥üî¥üî¥
            console.log(`\n${'üî¥'.repeat(20)}`);
            console.log(`üéØ ACTION ABOUT TO EXECUTE:`);
            console.log(`   Rule: ${rule.rule_name} (ID: ${ruleId})`);
            console.log(`   Object: ${obj.name} (ID: ${obj.id})`);
            console.log(`   Action Type: ${action.type}`);
            console.log(`   Action Value: ${action.value}`);
            console.log(`   Budget Mode: ${action.budgetMode || 'N/A'}`);
            console.log(`   Timestamp: ${new Date().toISOString()}`);
            console.log(`${'üî¥'.repeat(20)}\n`);

            const result = await executeAction(
              action,
              obj.id,
              adAccount.access_token,
              rule.advanced_settings || {},
              rule,
              obj,
              adAccount.currency // ‚úÖ Pass currency
            );

            executionResults.push({
              objectId: obj.id,
              objectName: obj.name,
              campaignId: obj.campaign_id || obj.id,
              campaignName: obj.campaign_name || obj.name,
              level: obj.level || rule.scope,
              action: action.type,
              result: "success",
              status: "completed",
              details: result,
              matchedConditions: obj._matchedConditions, // ‚úÖ NEW: Include matched conditions
              metrics: { // ‚úÖ NEW: Include actual metrics
                spend: obj.spend,
                results: obj.results,
                roi: obj.roi,
                roas: obj.roas
              },
              timestamp: new Date().toISOString()
            });

            console.log(`[execute-automation-rule] ‚úÖ Action ${action.type} executed successfully for ${obj.id}`);

            // ‚ú® Save pending revert if auto-revert is enabled
            console.log(`[execute-automation-rule] üîç Checking autoRevert:`, {
              autoRevert: action.autoRevert,
              revertAction: action.revertAction,
              revertAfterHours: action.revertAfterHours,
              revertAtTime: action.revertAtTime,
              willSchedule: !!(action.autoRevert && action.revertAction)
            });

            if (action.autoRevert && action.revertAction) {
              try {
                let revertAt = new Date();
                const now = new Date();

                if (action.revertAtTime) {
                  // Option 1: Revert at specific time (e.g. 09:00)
                  const [hours, minutes] = action.revertAtTime.split(':').map(Number);
                  // ‚úÖ FIX: Dynamic Timezone Handling
                  // Long-term solution: Use Ad Account's timezone offset
                  // Default to VN (+7) if offset is missing
                  let timezoneOffset = 7;
                  if (adAccount.timezone_offset_hours_utc !== undefined && adAccount.timezone_offset_hours_utc !== null) {
                    timezoneOffset = Number(adAccount.timezone_offset_hours_utc);
                  }

                  console.log(`[execute-automation-rule] üåç Timezone logic: User Input (Local) -> UTC (Server). Offset: ${timezoneOffset}`);

                  // Formula: UTC_Hour = User_Hour - Offset
                  // e.g. User 23:00 (VN +7) -> 23 - 7 = 16:00 UTC
                  // e.g. User 23:00 (NY -4) -> 23 - (-4) = 27 -> 03:00 Next Day UTC
                  revertAt.setHours(hours - timezoneOffset, minutes, 0, 0);

                  // If time passed (in relative UTC terms), move to tomorrow
                  // Logic: revertAt (Calculated UTC) <= now (Current UTC)
                  const timeDiff = now.getTime() - revertAt.getTime();
                  const GRACE_PERIOD_MS = 10 * 60 * 1000; // 10 minutes tolerance

                  // N·∫øu gi·ªù h·∫πn ƒê√É QUA (revertAt <= now)
                  // NH∆ØNG ch·ªâ qua m·ªôt ch√∫t (√≠t h∆°n 10 ph√∫t) -> Coi nh∆∞ l√† "H√¥m nay" (do ƒë·ªô tr·ªÖ Cron/Network) -> V·∫´n gi·ªØ ng√†y hi·ªán t·∫°i
                  if (revertAt <= now && timeDiff > GRACE_PERIOD_MS) {
                    revertAt.setDate(revertAt.getDate() + 1);
                    console.log(`[execute-automation-rule] üìÖ Revert time ${hours}:${minutes} passed by ${Math.round(timeDiff / 1000)}s (>10m), scheduled for TOMORROW`);
                  } else if (revertAt <= now) {
                    // Passed but within grace period
                    console.log(`[execute-automation-rule] ‚ö†Ô∏è Revert time ${hours}:${minutes} passed by ${Math.round(timeDiff / 1000)}s (<10m). Keeping TODAY (Grace Period).`);
                  }
                } else if (action.revertAfterHours) {
                  // Option 2: Revert after X hours (e.g. 1h, 0.5h)
                  // Convert hours to milliseconds: hours * 60 * 60 * 1000
                  const msToAdd = Number(action.revertAfterHours) * 60 * 60 * 1000;
                  revertAt = new Date(now.getTime() + msToAdd);
                } else {
                  // Fallback: Default to tomorrow 9 AM if nothing specified
                  revertAt.setHours(9, 0, 0, 0);
                  revertAt.setDate(revertAt.getDate() + 1);
                }

                console.log(`[execute-automation-rule] ‚è≥ Scheduling revert at ${revertAt.toISOString()}`);

                const revertPayload = {
                  rule_id: String(ruleId),
                  object_id: obj.id,
                  object_type: rule.scope,
                  revert_action: action.revertAction,
                  revert_value: JSON.stringify({ budgetBefore: (result as any).budgetBefore || 0 }), // ‚úÖ FIX: JSON type column requires JSON string
                  revert_at: revertAt.toISOString(),
                  status: 'pending',
                  user_id: userId
                };

                console.log(`[execute-automation-rule] üì¶ Revert payload:`, JSON.stringify(revertPayload));

                const revertResponse = await fetchWithTimeout(`${NOCODB_API_URL}/api/v2/tables/${TABLES.PENDING_REVERTS}/records`, {
                  method: 'POST',
                  headers: getNocoDBHeaders(),
                  body: JSON.stringify(revertPayload)
                });

                const revertResult = await revertResponse.text();
                console.log(`[execute-automation-rule] üìù Revert save response:`, {
                  status: revertResponse.status,
                  ok: revertResponse.ok,
                  body: revertResult.substring(0, 200)
                });

                if (!revertResponse.ok) {
                  console.error(`[execute-automation-rule] ‚ùå Failed to save revert to NocoDB:`, revertResult);
                }
              } catch (revertError) {
                console.error(`[execute-automation-rule] ‚ö†Ô∏è Failed to schedule revert:`, revertError);
              }
            }

          } catch (actionError) {
            console.error(`[execute-automation-rule] ‚ùå Action failed for ${obj.id}:`, actionError);
            executionResults.push({
              objectId: obj.id,
              objectName: obj.name,
              campaignId: obj.campaign_id || obj.id,
              campaignName: obj.campaign_name || obj.name,
              level: obj.level || rule.scope,
              action: action.type,
              result: "failed",
              status: "failed",
              error: actionError instanceof Error ? actionError.message : "Unknown error",
              timestamp: new Date().toISOString()
            });
          }
        }
      }

      // Update log with final results
      let logUpdateStatus = 0;
      let logUpdateText = "";
      if (pendingLogId) {
        // ‚úÖ OPTIMIZATION: Limit log size to prevent timeouts
        // Keep ALL matched/executed results
        const validResults = executionResults.filter(r => r.result !== 'condition_failed');

        // Keep up to 50 failed results (enough for debugging, prevents bloat)
        const failedResults = executionResults.filter(r => r.result === 'condition_failed').slice(0, 50);

        // If we have more than 50 failed, add a summary item
        if (executionResults.filter(r => r.result === 'condition_failed').length > 50) {
          failedResults.push({
            objectId: "OTHERS",
            objectName: `... v√† ${executionResults.filter(r => r.result === 'condition_failed').length - 50} ƒë·ªëi t∆∞·ª£ng kh√°c`,
            result: "condition_failed",
            status: "skipped",
            reason: "·∫®n b·ªõt ƒë·ªÉ t·ªëi ∆∞u hi·ªáu nƒÉng",
            timestamp: new Date().toISOString()
          });
        }

        const finalResults = [...validResults, ...failedResults];

        // ‚úÖ REFACTOR: Determine final status based on actions
        let finalStatus = 'success';

        // 1. If any action failed -> failed
        if (executionResults.some(r => r.status === 'failed')) {
          finalStatus = 'failed';
        }
        // 2. If NO objects matched at all -> waiting
        else if (matchedObjects.length === 0) {
          finalStatus = 'waiting';
        }
        // 3. ‚úÖ NEW: If matched objects exist but NO actions executed (all skipped) -> skipped
        const executedCount = executionResults.filter(r => r.status === 'completed').length;
        if (matchedObjects.length > 0 && executedCount === 0 && finalStatus !== 'failed') {
          finalStatus = 'skipped';
        }

        if (finalStatus === 'skipped' || finalStatus === 'waiting') {
          // üßπ User Requirement: Only keep Success/Failed logs. Delete skipped/waiting.
          console.log(`[execute-automation-rule] üßπ Deleting ${finalStatus} log ${pendingLogId} to keep history clean`);
          const deleteResponse = await fetchWithTimeout(`${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records`, {
            method: 'DELETE',
            headers: getNocoDBHeaders(),
            body: JSON.stringify([{ Id: pendingLogId }])
          });
          logUpdateStatus = deleteResponse.status;
          logUpdateText = "Deleted skipped log";
        } else {
          const logResponse = await fetchWithTimeout(`${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records`, {
            method: 'PATCH',
            headers: getNocoDBHeaders(),
            body: JSON.stringify({
              Id: pendingLogId,
              status: finalStatus,
              matched_objects_count: matchedObjects.length,
              executed_actions_count: executionResults.filter(r => r.status === 'completed').length,
              details: JSON.stringify(finalResults) // ‚úÖ Stringify optimized results
            })
          });
          logUpdateStatus = logResponse.status;
          if (!logResponse.ok) {
            logUpdateText = await logResponse.text();
            console.error(`[execute-automation-rule] ‚ùå Failed to update log ${pendingLogId}: ${logUpdateStatus} ${logUpdateText}`);
          }
        }
      }

      // Update rule execution status
      await fetchWithTimeout(
        `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATED_RULES}/records`,
        {
          method: "PATCH",
          headers: getNocoDBHeaders(),
          body: JSON.stringify({
            Id: rule.Id,
            last_execution_status: "success",
            last_run_at: new Date().toISOString(),
          }),
        }
      );
      return new Response(JSON.stringify({
        success: true,
        matchedCount: matchedObjects.length,
        results: executionResults,
        debug: {
          insightsFetched: typeof allInsights !== 'undefined' ? allInsights.length : 'undefined',
          insightsFiltered: typeof insights !== 'undefined' ? insights.length : 'undefined',
          startDate,
          endDate,
          labeledAdSetIds: labeledAdSetIds.length,
          labeledCampaignIds: labeledCampaignIds.length,
          logUpdateStatus: logUpdateStatus || 'skipped',
          logUpdateText: logUpdateText || ''
        }
      }), {
        headers: { ...corsHeaders, "Content-Type": "application/json" },
      });

    } catch (processingError) {
      // Handle processing errors
      console.error("[execute-automation-rule] Processing error:", processingError);
      throw processingError; // Re-throw to be caught by outer catch
    } finally {
      // üîì ALWAYS unlock the rule, even if there was an error
      try {
        console.log(`üîì [UNLOCK] Unlocking rule ${ruleId}...`);

        const unlockResponse = await fetchWithTimeout(
          `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATED_RULES}/records`,
          {
            method: 'PATCH',
            headers: getNocoDBHeaders(),
            body: JSON.stringify({
              Id: ruleId,
              processing_status: 'idle',
              processing_started_at: null,
            }),
          }
        );

        if (!unlockResponse.ok) {
          console.error(`‚ùå [UNLOCK] Failed to unlock rule ${ruleId}:`, unlockResponse.status);
        } else {
          console.log(`‚úÖ [UNLOCK] Rule ${ruleId} unlocked successfully`);
        }
      } catch (unlockError) {
        // Log but don't throw - we don't want unlock failure to hide the real error
        console.error(`‚ùå [UNLOCK] Error unlocking rule ${ruleId}:`, unlockError);
      }
    }

  } catch (error) {
    console.error("[execute-automation-rule] Error:", error);

    // ‚úÖ FIX: Update log status to failed if error occurs
    if (pendingLogId) {
      try {
        await fetch(`${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records`, {
          method: 'PATCH',
          headers: getNocoDBHeaders(),
          body: JSON.stringify({
            Id: pendingLogId,
            status: 'failed',
            details: JSON.stringify([{ message: error instanceof Error ? error.message : "Unknown error" }])
          })
        });
      } catch (logError) {
        console.error("Failed to update error log:", logError);
      }
    }
    return new Response(JSON.stringify({ error: error instanceof Error ? error.message : "Unknown error" }), {
      status: 500,
      headers: { ...corsHeaders, "Content-Type": "application/json" },
    });
  }
});

// Helper: Safe JSON parse (same logic as automatedRulesService.ts)
function safeJSONParse(value: any, fallback: any) {
  if (!value) return fallback;

  // If already correct type, return it
  if (typeof value !== 'string') {
    // If it's an object but we expect array, convert empty object to empty array
    if (Array.isArray(fallback) && typeof value === 'object' && !Array.isArray(value)) {
      // Empty object should become empty array
      if (Object.keys(value).length === 0) {
        return [];
      }
      // Single object should become array with one item
      if (value.id || value.type || value.metric) {
        return [value];
      }
    }
    return value;
  }

  try {
    // Try to parse once
    let parsed = JSON.parse(value);

    // If result is still a string, try parsing again (double-stringified)
    if (typeof parsed === 'string') {
      parsed = JSON.parse(parsed);
    }

    // If we expect an array but got an object
    if (Array.isArray(fallback)) {
      // Empty object should become empty array
      if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
        if (Object.keys(parsed).length === 0) {
          return [];
        }
        // Single object should become array with one item
        if (parsed.id || parsed.type || parsed.metric) {
          return [parsed];
        }
      }
    }

    return parsed || fallback;
  } catch (e) {
    console.error('[execute-automation-rule] ‚ö†Ô∏è JSON parse error:', e, value);
    return fallback;
  }
}

// Helper: Parse rule data from NocoDB (handle JSON strings)
function parseRuleData(rule: any) {
  return {
    ...rule,
    conditions: safeJSONParse(rule.conditions, []),
    actions: safeJSONParse(rule.actions, []),
    target_labels: safeJSONParse(rule.target_labels, []),
    advanced_settings: safeJSONParse(rule.advanced_settings, {})
  };
}

// Helper: Aggregate data by scope
function aggregateByScope(insights: any[], scope: string) {
  const aggregated: Record<string, any> = {};

  insights.forEach((insight) => {
    let id, name;

    if (scope === 'campaign') {
      id = insight.campaign_id;
      name = insight.campaign_name;
    } else if (scope === 'adset') {
      id = insight.adset_id;
      name = insight.adset_name;
    } else {
      id = insight.ad_id;
      name = insight.ad_name;
    }

    if (!id) return;

    if (!aggregated[id]) {
      aggregated[id] = {
        id,
        name,
        spend: 0,
        results: 0,
        impressions: 0,
        clicks: 0,
        campaign_id: insight.campaign_id,
        campaign_name: insight.campaign_name,
        adset_id: insight.adset_id,
        adset_name: insight.adset_name,
        level: scope
      };
    }

    // ‚úÖ FIX: Divide spend by 100 because Facebook stores it in cents (1/100 VND)
    aggregated[id].spend += parseFloat(insight.spend || 0) / 100;
    aggregated[id].results += parseInt(insight.results || 0);
    aggregated[id].impressions += parseInt(insight.impressions || 0);
    aggregated[id].clicks += parseInt(insight.clicks || 0);
  });

  return Object.values(aggregated);
}

// Helper: Evaluate conditions
function evaluateConditions(obj: any, conditions: RuleCondition[], logic: string) {
  if (!conditions || conditions.length === 0) return true;

  if (logic === 'OR') {
    return conditions.some((condition) => {
      return evaluateSingleCondition(obj[condition.metric], condition.operator, condition.value);
    });
  } else {
    // AND
    return conditions.every((condition) => {
      return evaluateSingleCondition(obj[condition.metric], condition.operator, condition.value);
    });
  }
}

function evaluateSingleCondition(actualValue: number, operator: string, threshold: number) {
  // Handle undefined/null values as 0
  const value = actualValue || 0;

  // Normalize operator
  let op = operator;
  if (operator === 'greater_than') op = '>';
  else if (operator === 'greater_than_or_equal') op = '>=';
  else if (operator === 'less_than') op = '<';
  else if (operator === 'less_than_or_equal') op = '<=';
  else if (operator === 'equals' || operator === 'equal') op = '=';
  else if (operator === 'not_equals' || operator === 'not_equal') op = '!=';

  switch (op) {
    case '>': return value > threshold;
    case '>=': return value >= threshold;
    case '<': return value < threshold;
    case '<=': return value <= threshold;
    case '=': return value == threshold; // Use == for loose equality to handle string/number
    case '!=': return value != threshold;
    default: return false;
  }
}

// Helper: Execute action
async function executeAction(
  action: RuleAction,
  objectId: string,
  token: string,
  advancedSettings: any,
  rule: any,
  obj: any,
  currency: string
) {
  const targetCampaignId = obj.campaign_id || obj.id;

  switch (action.type) {
    case 'turn_off':
      console.log(`\n${'‚õî'.repeat(20)}`);
      console.log(`‚õî EXECUTING TURN_OFF ACTION:`);
      console.log(`   Object: ${objectId}`);
      console.log(`   Sending status: PAUSED to Facebook API`);
      console.log(`${'‚õî'.repeat(20)}\n`);
      console.log(`[execute-automation-rule] üõë Turning off ${objectId}`);

      // ‚úÖ STEP 0: Check current status from Facebook API first
      // This prevents scheduling a revert if the campaign is already paused manually
      const statusCheckResponse = await fetchWithTimeout(`https://graph.facebook.com/v18.0/${objectId}?fields=status,effective_status`, {
        method: 'GET',
        headers: { 'Authorization': `Bearer ${token}` }
      });

      if (statusCheckResponse.ok) {
        const currentObj = await statusCheckResponse.json();
        const currentStatus = currentObj.status;
        const effectiveStatus = currentObj.effective_status;

        console.log(`[execute-automation-rule] üîç Current status for ${objectId}: ${currentStatus} (Effective: ${effectiveStatus})`);

        if (currentStatus === 'PAUSED' || currentStatus === 'ARCHIVED' || currentStatus === 'DELETED') {
          console.log(`[execute-automation-rule] ‚ö†Ô∏è Object is already ${currentStatus}. Skipping turn_off action.`);
          return {
            success: true,
            action: 'turn_off',
            status: 'skipped',
            reason: `Already ${currentStatus}`,
            details: `Object status is ${currentStatus}, action skipped.`
          };
        }
      } else {
        console.warn(`[execute-automation-rule] ‚ö†Ô∏è Failed to check current status. Proceeding with turn_off anyway.`);
      }

      // Call Facebook API to pause
      const pauseResponse = await fetchWithTimeout(`https://graph.facebook.com/v18.0/${objectId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          status: 'PAUSED',
          access_token: token
        })
      });

      if (!pauseResponse.ok) {
        const err = await pauseResponse.json();
        throw new Error(`Facebook API Error: ${err.error?.message || 'Unknown error'}`);
      }

      // Record execution REMOVED here as we use main executionResults

      return { success: true, action: 'turn_off' };

    case 'turn_on':
      console.log(`\n${'‚úÖ'.repeat(20)}`);
      console.log(`‚úÖ EXECUTING TURN_ON ACTION:`);
      console.log(`   Object: ${objectId}`);
      console.log(`   Sending status: ACTIVE to Facebook API`);
      console.log(`${'‚úÖ'.repeat(20)}\n`);
      console.log(`[execute-automation-rule] ‚ñ∂Ô∏è Turning on ${objectId}`);
      const startResponse = await fetchWithTimeout(`https://graph.facebook.com/v18.0/${objectId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          status: 'ACTIVE',
          access_token: token
        })
      });

      if (!startResponse.ok) {
        const err = await startResponse.json();
        throw new Error(`Facebook API Error: ${err.error?.message || 'Unknown error'}`);
      }

      // Record execution REMOVED here

      return { success: true, action: 'turn_on' };

    case 'increase_budget':
    case 'decrease_budget':
      // Check if campaign uses CBO (Campaign Budget Optimization)
      // If scope is 'adset' but campaign uses CBO, we CANNOT update adset budget.
      // We must check the campaign first.

      console.log(`[execute-automation-rule] üí∞ Checking budget type for campaign ${targetCampaignId}`);
      const campaignCheckResponse = await fetchWithTimeout(
        `https://graph.facebook.com/v18.0/${targetCampaignId}?fields=name,daily_budget,lifetime_budget,buying_type,bid_strategy,budget_remaining`,
        {
          headers: { Authorization: `Bearer ${token}` }
        }
      );

      if (!campaignCheckResponse.ok) {
        console.warn(`[execute-automation-rule] ‚ö†Ô∏è Could not check campaign budget type. Proceeding with caution.`);
      }

      const campaignCheckData = await campaignCheckResponse.json();
      const isCBO = campaignCheckData.daily_budget || campaignCheckData.lifetime_budget;
      const isCampaignScope = rule.scope === 'campaign';

      if (isCBO) {
        // Campaign uses CBO
        if (isCampaignScope) {
          // ‚úÖ Update campaign budget
          console.log('[execute-automation-rule] ‚úÖ Campaign uses CBO, updating campaign budget');
          const result = await updateBudgetForObject(
            targetCampaignId,
            'campaign',
            action,
            token,
            advancedSettings,
            currency // ‚úÖ Pass currency
          );

          // ‚úÖ Record execution history REMOVED here

          return result;
        } else {
          // ‚ùå User selected adset scope but campaign uses CBO
          throw new Error(
            `‚ùå Campaign "${campaignCheckData.name}" ƒëang d√πng Campaign Budget Optimization (CBO).\n\n` +
            `üìå Vui l√≤ng ƒë·ªïi rule scope th√†nh "Campaign" thay v√¨ "Ad Set" ƒë·ªÉ ƒëi·ªÅu ch·ªânh ng√¢n s√°ch.`
          );
        }
      } else {
        // ‚ùå Campaign uses Adset Budget
        if (isCampaignScope) {
          // üî¥ CRITICAL: Reject to prevent multiplying budget across all adsets
          throw new Error(
            `‚ùå Kh√¥ng th·ªÉ tƒÉng/gi·∫£m ng√¢n s√°ch cho campaign "${campaignCheckData.name}" v√¨ ƒëang d√πng Adset Budget.\n\n` +
            `‚ö†Ô∏è C·∫¢NH B√ÅO: N·∫øu rule ch·∫°y v·ªõi scope "Campaign", ng√¢n s√°ch s·∫Ω tƒÉng CHO M·ªñI adset active, ` +
            `d·∫´n ƒë·∫øn t·ªïng ng√¢n s√°ch tƒÉng g·∫•p nhi·ªÅu l·∫ßn (v√≠ d·ª•: 9 adsets √ó 65k √ó 1.2 = 702k).\n\n` +
            `üìå ƒê·ªÉ tr√°nh v·∫•n ƒë·ªÅ n√†y, vui l√≤ng:\n` +
            `1Ô∏è‚É£ ƒê·ªïi rule scope th√†nh "Ad Set" v√† g·∫Øn label cho c√°c adset c·ª• th·ªÉ b·∫°n mu·ªën ƒëi·ªÅu ch·ªânh\n` +
            `2Ô∏è‚É£ Ho·∫∑c chuy·ªÉn campaign sang Campaign Budget Optimization (CBO) trong Facebook Ads Manager`
          );
        } else {
          // ‚úÖ User correctly selected adset scope ‚Üí update this specific adset
          console.log('[execute-automation-rule] ‚úÖ Campaign uses Adset Budget, updating specific adset');
          const result = await updateBudgetForObject(
            objectId,
            'adset',
            action,
            token,
            advancedSettings,
            currency // ‚úÖ Pass currency
          );

          // ‚úÖ Record execution history REMOVED here

          return result;
        }
      }

    case 'remove_label':
      const labelId = action.value;
      if (!labelId) throw new Error("Missing label ID for remove_label action");

      console.log(`[execute-automation-rule] üè∑Ô∏è Removing label ${labelId} from ${objectId} (${level})`);

      // 1. Find the assignment ID in CAMPAIGN_LABEL_ASSIGNMENTS
      let query = `(label_id,eq,${labelId})`;
      if (level === 'campaign') query += `~and(campaign_id,eq,${objectId})`;
      else if (level === 'adset') query += `~and(adset_id,eq,${objectId})`;
      else if (level === 'ad') query += `~and(ad_id,eq,${objectId})`;

      const findAssignResponse = await fetchWithTimeout(
        `${NOCODB_API_URL}/api/v2/tables/${TABLES.CAMPAIGN_LABEL_ASSIGNMENTS}/records?where=${encodeURIComponent(query)}`,
        {
          headers: getNocoDBHeaders()
        }
      );

      if (!findAssignResponse.ok) {
        throw new Error(`Failed to find label assignment: ${await findAssignResponse.text()}`);
      }

      const assignData = await findAssignResponse.json();
      const assignments = assignData.list || [];

      if (assignments.length === 0) {
        console.log(`[execute-automation-rule] ‚ö†Ô∏è Assignment not found, might have been removed already.`);
        return { success: true, message: "Label already removed or not found" };
      }

      // 2. Delete all matching assignments
      for (const assignment of assignments) {
        const deleteResponse = await fetchWithTimeout(
          `${NOCODB_API_URL}/api/v2/tables/${TABLES.CAMPAIGN_LABEL_ASSIGNMENTS}/records`,
          {
            method: 'DELETE',
            headers: getNocoDBHeaders(),
            body: JSON.stringify({ Id: assignment.Id })
          }
        );

        if (!deleteResponse.ok) {
          throw new Error(`Failed to delete assignment ${assignment.Id}: ${await deleteResponse.text()}`);
        }
      }

      return {
        success: true,
        message: `ƒê√£ g·ª° nh√£n kh·ªèi ${level} ${objectId}`
      };

    default:
      throw new Error(`Unknown action type: ${action.type}`);
  }
}

// ==========================================
// üß© HELPER FUNCTIONS (Restored)
// ==========================================

function getDateRange(timeRange: string, timezone: string) {
  const now = new Date();
  const options: Intl.DateTimeFormatOptions = { timeZone: timezone, year: 'numeric', month: '2-digit', day: '2-digit' };
  const formatter = new Intl.DateTimeFormat('en-CA', options); // YYYY-MM-DD format

  const getDateString = (date: Date) => formatter.format(date);

  let startDate = new Date(now);
  let endDate = new Date(now);

  switch (timeRange) {
    case 'today':
      // startDate = endDate = today
      break;
    case 'yesterday':
      startDate.setDate(now.getDate() - 1);
      endDate.setDate(now.getDate() - 1);
      break;
    case 'last_3d':
      startDate.setDate(now.getDate() - 2); // Today + 2 days back = 3 days
      break;
    case 'last_7d':
      startDate.setDate(now.getDate() - 6);
      break;
    case 'last_14d':
      startDate.setDate(now.getDate() - 13);
      break;
    case 'last_30d':
      startDate.setDate(now.getDate() - 29);
      break;
    case 'this_month':
      startDate.setDate(1);
      break;
    case 'last_month':
      startDate.setMonth(now.getMonth() - 1);
      startDate.setDate(1);
      endDate.setDate(0); // Last day of previous month
      break;
    default:
      // Default to today
      break;
  }

  return {
    startDate: getDateString(startDate),
    endDate: getDateString(endDate)
  };
}

function getCurrencySettings(currency: string) {
  const settings: Record<string, { symbol: string; locale: string }> = {
    'VND': { symbol: '‚Ç´', locale: 'vi-VN' },
    'USD': { symbol: '$', locale: 'en-US' },
    'EUR': { symbol: '‚Ç¨', locale: 'de-DE' },
  };
  return settings[currency] || { symbol: '', locale: 'en-US' };
}

async function updateBudgetForObject(
  objectId: string,
  objectType: 'campaign' | 'adset',
  action: RuleAction,
  token: string,
  advancedSettings: any,
  currency: string
) {
  const url = `https://graph.facebook.com/v18.0/${objectId}`;

  // 1. Fetch current budget
  const response = await fetchWithTimeout(`${url}?fields=daily_budget,lifetime_budget,name`, {
    headers: { Authorization: `Bearer ${token}` }
  });

  if (!response.ok) {
    throw new Error(`Failed to fetch budget for ${objectType} ${objectId}`);
  }

  const data = await response.json();
  const currentDaily = data.daily_budget ? parseInt(data.daily_budget) : 0;
  const currentLifetime = data.lifetime_budget ? parseInt(data.lifetime_budget) : 0;
  const isDaily = currentDaily > 0;
  const currentBudget = isDaily ? currentDaily : currentLifetime;

  if (currentBudget === 0) {
    throw new Error(`Budget is 0 or not set for ${objectType} ${objectId}`);
  }

  // 2. Calculate new budget
  let newBudget = currentBudget;
  const value = Number(action.value);

  // üîß FIX: Frontend sends 'valueType', backend was expecting 'budgetMode'
  // Accept both for compatibility
  const budgetMode = action.budgetMode || (action as any).valueType || 'percentage';
  console.log(`[execute-automation-rule] üìä Budget calculation mode: ${budgetMode}, value: ${value}`);

  if (budgetMode === 'percentage') {
    const multiplier = 1 + (value / 100);
    newBudget = action.type === 'increase_budget'
      ? currentBudget * multiplier
      : currentBudget / multiplier; // Decrease: budget / 1.1 for 10%

    // For decrease, usually it's budget * (1 - percent/100) but "decrease by 10%" often means 90% of original.
    // If action.value is 10 (%), increase is * 1.1. Decrease is * 0.9.
    if (action.type === 'decrease_budget') {
      newBudget = currentBudget * (1 - (value / 100));
    }
  } else {
    // Absolute
    newBudget = action.type === 'increase_budget'
      ? currentBudget + value
      : currentBudget - value;
  }

  newBudget = Math.round(newBudget);

  // 3. Validate limits (Min/Max)
  // Facebook min for VND is usually ~23,000. Let's assume 20000 safe.
  if (newBudget < 20000 && currency === 'VND') newBudget = 20000;

  // Check user defined limits - support both field naming conventions
  // Frontend uses: maxBudgetDailySpend, minBudgetDailySpend
  // Legacy: maxBudget, minBudget
  const maxBudgetLimit = advancedSettings?.maxBudgetDailySpend || advancedSettings?.maxBudget;
  const minBudgetLimit = advancedSettings?.minBudgetDailySpend || advancedSettings?.minBudget;

  if (maxBudgetLimit && newBudget > maxBudgetLimit) {
    console.log(`[execute-automation-rule] ‚ö†Ô∏è Budget ${newBudget} exceeds max limit ${maxBudgetLimit}, capping`);
    newBudget = maxBudgetLimit;
  }
  if (minBudgetLimit && newBudget < minBudgetLimit) {
    console.log(`[execute-automation-rule] ‚ö†Ô∏è Budget ${newBudget} below min limit ${minBudgetLimit}, raising`);
    newBudget = minBudgetLimit;
  }

  // 4. Update
  const updatePayload: any = {};
  if (isDaily) updatePayload.daily_budget = newBudget;
  else updatePayload.lifetime_budget = newBudget;

  console.log(`[execute-automation-rule] üßÆ Budget Update: ${currentBudget} -> ${newBudget} (${action.type})`);
  console.log(`[execute-automation-rule] üì° Sending payload to FB:`, JSON.stringify(updatePayload));

  const updateResponse = await fetchWithTimeout(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      ...updatePayload,
      access_token: token
    })
  });

  if (!updateResponse.ok) {
    const err = await updateResponse.json();
    throw new Error(`Facebook API Error: ${err.error?.message || 'Unknown error'}`);
  }

  return {
    success: true,
    budgetBefore: currentBudget,
    budgetAfter: newBudget,
    objectName: data.name
  };
}

async function recordExecution(
  ruleId: number,
  objectId: string,
  objectType: string,
  userId: string,
  actionType: string,
  budgetBefore: number,
  budgetAfter: number,
  metadata: any
) {
  try {
    const logData = {
      rule_id: ruleId,
      object_id: objectId,
      object_type: objectType,
      user_id: userId,
      action_type: actionType,
      executed_at: new Date().toISOString(),
      status: 'success',
      details: JSON.stringify({
        budget_before: budgetBefore,
        budget_after: budgetAfter,
        ...metadata
      })
    };

    await fetchWithTimeout(`${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records`, {
      method: 'POST',
      headers: getNocoDBHeaders(),
      body: JSON.stringify(logData)
    });
  } catch (e) {
    console.error('[execute-automation-rule] ‚ö†Ô∏è Failed to record execution log:', e);
  }
}

async function fetchWithTimeout(resource: string, options: any = {}) {
  const { timeout = 8000 } = options;

  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);

  try {
    const response = await fetch(resource, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(id);
    return response;
  } catch (error) {
    clearTimeout(id);
    throw error;
  }
}

function shouldExecuteNow(executeAt: string) {
  if (!executeAt) return true;
  const [targetHour, targetMinute] = executeAt.split(':').map(Number);
  const now = new Date();
  // Simple check: if current hour matches target hour (within 59 mins)
  // A better cron would be needed for exact minute precision, but for now:
  return now.getHours() === targetHour;
}
// Check execution history to prevent exceeding max executions per object
async function checkExecutionHistory(
  ruleId: number,
  objectId: string,
  objectType: string,
  userId: string,
  actionType: string,
  settings: any
) {
  // If manual run, always allow
  if (settings?.manualRun) {
    console.log(`[checkExecutionHistory] ‚úÖ Manual run - always allowed`);
    return { canExecute: true, reason: "Manual run" };
  }

  // ‚úÖ NEW: If execution limits are disabled via toggle, always allow
  if (settings?.enableExecutionLimits === false) {
    console.log(`[checkExecutionHistory] ‚úÖ Execution limits disabled - always allowed`);
    return { canExecute: true, reason: "Execution limits disabled" };
  }

  // ‚úÖ FIX: Get maxExecutionsPerObject from settings (default: unlimited = 0)
  const maxExecutions = settings?.maxExecutionsPerObject || 0;
  const cooldownHours = settings?.cooldownHours || 0;

  console.log(`[checkExecutionHistory] üîç Checking limits for object ${objectId}:`, {
    maxExecutions,
    cooldownHours,
    ruleId,
    actionType
  });

  // If no limits set, allow
  if (maxExecutions === 0 && cooldownHours === 0) {
    console.log(`[checkExecutionHistory] ‚úÖ No limits configured - always allowed`);
    return { canExecute: true, reason: "No limits configured" };
  }

  // Fetch execution logs for this rule
  // We need to get logs and parse details JSON to count per-object executions
  const whereClause = encodeURIComponent(`(rule_id,eq,${ruleId})~and(status,eq,success)`);

  const response = await fetchWithTimeout(
    `${NOCODB_API_URL}/api/v2/tables/${TABLES.AUTOMATION_RULE_EXECUTION_LOGS}/records?where=${whereClause}&sort=-executed_at&limit=100`,
    {
      method: 'GET',
      headers: getNocoDBHeaders()
    }
  );

  if (!response.ok) {
    console.log(`[checkExecutionHistory] ‚ö†Ô∏è Could not fetch history - allowing execution`);
    return { canExecute: true, reason: "Could not fetch history" };
  }

  const data = await response.json();
  const logs = data.list || [];

  if (logs.length === 0) {
    console.log(`[checkExecutionHistory] ‚úÖ No previous executions - allowing`);
    return { canExecute: true, reason: "No previous executions" };
  }

  // Parse details from each log to find executions for this specific object
  let executionCount = 0;
  let lastExecutionTime: Date | null = null;

  for (const log of logs) {
    try {
      // Parse details - could be string or already object
      const details = typeof log.details === 'string'
        ? JSON.parse(log.details)
        : (log.details || []);

      if (!Array.isArray(details)) continue;

      // Find executions for this specific object with success status
      for (const result of details) {
        if (result.objectId === objectId &&
          result.action === actionType &&
          (result.status === 'completed' || result.result === 'success')) {
          executionCount++;

          // Track most recent execution time
          const execTime = new Date(result.timestamp || log.executed_at);
          if (!lastExecutionTime || execTime > lastExecutionTime) {
            lastExecutionTime = execTime;
          }
        }
      }
    } catch (e) {
      console.error(`[checkExecutionHistory] Error parsing log details:`, e);
    }
  }

  console.log(`[checkExecutionHistory] üìä Found ${executionCount} previous executions for object ${objectId}`);

  // ‚úÖ Check maxExecutionsPerObject limit
  // FIX: Ensure types are correct for comparison
  const limit = Number(maxExecutions);

  if (limit > 0 && executionCount >= limit) {
    console.log(`[checkExecutionHistory] ‚ùå Exceeded max executions (${executionCount} >= ${limit}) for ${objectId}`);
    return {
      canExecute: false,
      reason: `ƒê√£ ƒë·∫°t gi·ªõi h·∫°n ${limit} l·∫ßn th·ª±c thi (ƒê√£ ch·∫°y: ${executionCount})`,
      executionCount
    };
  }

  // ‚úÖ Check cooldown period
  if (cooldownHours > 0 && lastExecutionTime) {
    const cooldownMs = cooldownHours * 60 * 60 * 1000;
    const timeSinceLastExecution = Date.now() - lastExecutionTime.getTime();

    if (timeSinceLastExecution < cooldownMs) {
      const hoursRemaining = ((cooldownMs - timeSinceLastExecution) / (60 * 60 * 1000)).toFixed(1);
      console.log(`[checkExecutionHistory] ‚ùå Still in cooldown period (${hoursRemaining}h remaining)`);
      return {
        canExecute: false,
        reason: `C√≤n ${hoursRemaining} gi·ªù ch·ªù tr∆∞·ªõc khi ch·∫°y l·∫°i`,
        executionCount,
        lastExecutionTime: lastExecutionTime.toISOString()
      };
    }
  }

  console.log(`[checkExecutionHistory] ‚úÖ All checks passed - allowing execution`);
  return {
    canExecute: true,
    reason: "All execution limits passed",
    executionCount
  };
}
